Funcionamiento del sistema de prioridades

Se incorporan 20 procesos donde se les asignan prioridades respectivas, con inicialización en 0 y boost en 1. Tal como se pudo estudiar en la Prueba 1, mientras mayor es la prioridad el planificador prefiere escoger ese proceso para su ejecución. Este valor de prioridad se rige por un ajuste propuesto por el boost, donde si la prioridad llega a 9, el boost reduce su prioridad con -1 y si prioridad es 0, boost aumenta su valor de prioridad por +1. Dando orden para que el scheduler seleccione el proceso con mayor prioridad para ejecución, siendo estos los con menor valor numérico.

Modificaciones realizadas

En los documentos, tanto proc.c como proc.h se modificaron, donde el primero inicializa los valores de prioridad y boost, y el segundo contiene la estructura de los procesos, detallando los campos de prioridad y boost.
El ambiente lógico del scheduler también se gestiona en proc.c, donde se ajustan el boost y la prioridad de cada proceso en la cola de ejecución. El scheduler selecciona los procesos en orden, priorizando aquellos con el menor valor numérico de prioridad. Ordenando así las prioridades de mayor a menor prioridad.

Dificultades y soluciones

El orden de prioridades fue particularmente difícil al momento de desarrollar el sistema lógico del scheduler, pero luego de implementar la lógica de boost +1 y -1 de manera correcta, lo demás fue utilizar condicionales lógicas para poder escoger el valor con menor prioridad. Por lo tanto, una correcta asignación de los valores numéricos de prioridad es crucial para mantener la integridad del orden de ejecución de los procesos, ya que todas las decisiones de selección del scheduler dependen de estos valores.

Por otro lado, trabajar con máquinas virtuales siempre le genera problemas a mi computador, en especial si debo utilizar IDEs de alto consumo como lo es VScode. Esto realmente dificulta mi facilidad para programar y desplazarme por la pantalla a través de los multiples documentos de código, pero encontré mucho más práctico únicamente correr QEMU en la máquina virtual, pero desarrollar la programación en Windows. Así agilizando mi desarrollo del trabajo.
